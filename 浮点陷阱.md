1、在竞赛中，可能存在给一个double多次计算后，非常接近0的情况，但是，它可能是-0.000000000000000001（一下子举不出实际的例子……），这时输出会变成-0.00，在一部分精确比较的题目上可能会出错，解决方案为输出的时候加上一个EPS（当然不能排除出题人自己煞笔的情况……），即printf("%f", ans + EPS)。

2、如果一个double，要把一个数组里的浮点数累加起来（即 double sum = accumlate(arr.begin(), arr.end(), 0)），如果数组里的数相差可能会比较大，应该从小到大累加。否则可能会发生加了一个很大的浮点数之后，再加一个很小的浮点数，因为精度的原因，跟没加一样（比如一个极端的例子，1e100 + 1e-100还是等于1e100）。因为比较小的数多了，还是会影响到答案的，并不是可以简简单单被忽略的。

3、在计算一个数减去一组数的时候（即double sum = x - accumlate(arr.begin(), arr.end(), 0)），应该先把数组里的数全加起来，再用那个数来减。否则跟上面一样，可能会出现减去了一个很小的数，跟没减一样。

4、二分的时候，EPS设置不当，可能会出现奇怪的问题（特别是有多次二分而对着两次二分要求的精度不一样的时候），这时可以采取另一种写法：

```C++
double binary_search(double l, double r) {
    for(int i = 0; i < 100; ++i) {
        double mid = (l + r) / 2;
        if(check(mid)) l = mid;
        else r = mid;
    }
    return l;
}
```

循环次数可按需设置，一般100都够，对时间要求高可以设小一点。

5、在连乘的时候，浮点数可能会丢比较多的精度，此时可以利用公式x1 * x2 * …… * xn = exp(ln(x1 * x2 * …… * xn)) = exp(ln(x1) + ln(x2) + ……ln(xn))，取他们的对数相加，再求次幂。

比如在计算阶乘的时候，可以：

```C++
double Factorial(int n) {
    double res = 0;
    for(int i = 1; i <= n; ++i)
        res += log(i);
    return exp(res);
}
```

当然有必要的时候（其实是大多时候）我们可以先不exp()先返回，作完后续运算再exp()
